2.88 ◆
We are running programs on a machine where values of type int have a 32- bit two’s-complement representation. Values of type float use the 32-bit IEEE format, and values of type double use the 64-bit IEEE format.

We generate arbitrary integer values x, y, and z, and convert them to values of type double as follows:

/* Create some arbitrary values */
int x = random();
int y = random();
int z = random();
/* Convert to double */
double   dx = (double) x;
double   dy = (double) y;
double   dz = (double) z;

For each of the following C expressions, you are to indicate whether or not the expression always yields 1. If it always yields 1, describe the underlying mathematical principles. Otherwise, give an example of arguments that make it yield 0. Note that you cannot use an IA32 machine running gcc to test your answers, since it would use the 80-bit extended-precision representation for both float and double.

A. (float) x == (float) dx 

This does always yield 1. 

Casting to a float can cause rounding; however, x and dx are going to be rounded the same way.

B. dx - dy == (double) (x-y)

[ Casted ints to doubles then subtracted VERSUS ints subtracted then casted to double ]

This will NOT always yield 1. 

Ex. x = random() = 0 and  y = random() = -2147483648 (TMin) = -2^(w-1) where w = 32  --> OF

LHS: ints x and y are casted into dx and dy, then dx and dy are subtracted // 2 degrees misprecision
RHS: ints x and y are subtracted, then casted as a double // 1 degree of misprecision

Note: The 2's complement of TMin is Tmin

C. (dx+dy)+dz == dx+(dy+dz)

The following is true for real arithmetic (Lecture Notes):
	a+ (b+c) = (a+b) + c
- But this is not the certain case for floating point. 
- The inexactness can occur from two rounding errors.
However, dz,dy,dz are elements between -2^(w-1) and 2^(w-1) - 1 so it seems to be the case that this will yield 1 most of the time.

D. (dx*dy)*dz == dx*(dy*dz)

Multiplying in different order can lead to unexpected results on either side.
So no. This does not always yield 1.

Ex. dx = 2^(w-1) - 1 // Tmax
dy = 2^(w-1) - 2 // Tmax - 1
dz = 2^(w-1) - 3 // Tmax - 2

E. dx/dx == dz/dz

No. This does not always yield 1. Consider the divide by 0 case for one of the double variables. Dividing by 0 can result in NaN.

2.89 ◆

You have been assigned the task of writing a C function to compute a floating- point representation of 2x. You decide that the best way to do this is to directly construct the IEEE single-precision representation of the result. 

When x is too small, your routine will return 0.0. When x is too large, it will return +∞. Fill in the blank portions of the code that follows to compute the correct result. 

Assume the function u2f returns a floating-point value having an identical bit representation as its unsigned argument.

float fpwr2(int x)
{
    /* Result exponent and fraction */
    unsigned exp, frac;
    unsigned u;
	if (x < -149) // -149 because the bias is equal to 2^(8-1) - 1, which is 127. And 1-Bias is -126. The smallest representation would // therefore be 2^-126 * 2^-23, -23 because the is the amount of bits in the frac component of a floating-point representation.
	{
		/* When X is Too small. Return 0.0 */ 
		exp = 0; // Value of exp should be 0
		frac = 0; // Value of frac should be 0
	} 
	else if (x < -126)  // 1-Bias
	{
	/* Denormalized result */
		exp = 0￼ ;
		frac = ￼1 << (x + 149);  // -149 is the smallest representation, so you would shift it x + 149 amount to represent the value //2^x that you want. Ex. 2^-148 would mean you shift it once to the left for 0.00000000000000000000001 (23 frac bits) to 
		// 0.00000000000000000000001
	} 
	else if (x < 128) 
	{
￼  		/* Normalized result. */
		exp = x + 127; // Ex. e-bias. If you want 2^0 e = 127 f = 0 and e-bi
		frac = 0; 
	} 
	else 
	{
        /* Too big.  Return +oo */
		exp = 255 ; // Representation of infinity
		frac = 0 ; 
	}

    /* Pack exp and frac into 32 bits */
    u = exp << 23 | frac;
    /* Return as float */
    return u2f(u); // Assume this returns a floating-pint value by having an identical bit representation as it's unsigned argument
}
