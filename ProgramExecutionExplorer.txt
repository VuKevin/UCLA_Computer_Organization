/* Kevin Vu, CS33 PEXEX Lab, Fall 2015 */

01. Explain why the instructions in the trace did not produce the correct mathematical result. Which instructions caused the problem, exactly?
The correct mathematical result did not occur from the instructions in the trace since the Lisp objects are only 62 bits long. In the 62 bit case, the computation results in an overflow. In the 64 bit case, this is not necessarily an overflow. More specifically, the instruction that led to this error was lea 0x0(,%rbp,4), %rax in which the multiplicated becomes bigger than anticipated.

02. Explain why the shell command emacs -batch -eval '(print most-positive-fixnum)' outputs 2305843009213693951. Where did the number 2305843009213693951 come from? Explain in terms of the Emacs source code.
2305843009213693951 if rewritten as 2^61-1, sheds more light on why this was outputed. Examining the source code contents of lisp.h has '#define MOST_POSITIVE_FIXNUM (EMACS_INT_MAX >> INTTYPEBITS).' In a 64 bit machine, this would be 0x7fffffffffffffff shifted right INTTYPEBITS or also GCTYPEBITS-1. GCTYPEBITS is 3 so 0x7fffffffffffffff is shifted right by 2. EMACS_INT_MAX is shifted right by 2. This is going to be 2^61-1 and thus why the shell command outputs this.


03. Explain why the shell command emacs -batch -eval '(print (* most-positive-fixnum most-positive-fixnum))' outputs only 1.
When squaring numbers, bit shifting occurs first then adding one. When squaring most-postitive-fixnum, the shift will result in 0 and adding 1 will essentially make the result out to be 1.


04. The Emacs executable was compiled with GCC's -O2 option. Suppose it had also been compiled with -fsanitize=undefined. Explain any problems the trace would run into, or if there would not be a problem explain why not.
Running with -fsanitize=undefine, a diagnostic message would appear every encounter of overflow at runtime. Execution won't be halted, but continued. This flag doesn't change anything since no overflow was found in the trace.

05. Similarly, discuss whether and how -fwrapv would have caused problems.
Running with -fwrapv, arithmetic operations would just continue and if there was overflow it would wrap around using the 2's complement mechanism. There would not be problems as no overflow was encountered in the trace.

06. Suppose we assume -fwrapv is used. Suggest changes to how Emacs does integer multiplication that should help improve its performance. Focus on integer multiplication; don't alter the machinery Emacs uses to decide which flavor of multiplication to do.
If -fwrapv is assumed to be used, the overflow checks would be unnecessary. As such, we would just solely multiply instead.


07. How significant are the efficiency differences discussed above, in the context of Emacs execution?
It won't make a significant difference in efficiency: there are less than 4 (2-3) switch statement checks of OF. The speed may potentially raise, but nothing too drastic.

================================================================================================================

pexexlab.txt
Kevin Vu CS 33 Fall 2015

Keep a log in the file pexexlab.txt of what you do in the lab so that you can reproduce the results later. This should not merely be a transcript of what you typed: it should be more like a lab notebook, in which you briefly note down what you did and what happened. It should record not just what worked, but also what didn't work.

-> Accessed lnxsrv09.seas.ucla.edu via Putty
-- gdb ~eggert/bin64/bin/emacs-24.5    //  GDB start, don't forget the two bins or you'll be accessing something weird
-- break Ftimes //  A breakpoint set @ Ftimes
-- r -batch -eval '(print (* 6997 -4398042316799 179))'   // Run the program
-- set disassemble-next-line on // Print the assembly code each step

*At this point, I used stepi and step to manuever throughout the program and using info registers $xxx to obtain information about the changes being made to the registers. Note: Omitting the $ will give the same result. If I needed to start over because of having to move locations or a mistake, just 'run' again. Even if the jump didn't occur, I still recorded rip to indicate that. Total lines anticipated: 144 

Misc GDB Commands for those interested:
- Setting watch points [watch] [target]
- Setting break points [break] [target]
- Getting info info [target]
- Continue execution until next break c[ontinue]
- Disassembling a function disas[semble] fxn
- Display [target]
- Running gdp on fxn.c: gdb fxn.c

Making a compressed tar file: Pexex in home directory and move all files into it.
In Linux, tar -cvzf pexex.tgz pexex

Pwd to see where you are in the directory.
Wrong command line: gdb ~eggert/bin64/bin/emacs-24.5 // you need the gdb else it will be a menu with emac tutorials
Text Editor used: Sublime text: Use alt/option with your mouse to select boxes of text at a time.
This Program Execution Explorer Lab is designed to force us to learn the uses of GDB hands on.

================================================================================================================

  #include <limits.h>
  #include <stdbool.h>
  long big = LONG_MAX;
  bool
  testovf (void)
  {
    return big + LONG_MAX < big; // return true if (0x7fffffffffffffff + 0x7fffffffffffffff) < 0x7fffffffffffffff)
  }
  
  // *Annotated Assembly Code* //
 /* 
  Disassembly of section .text: // with -O2

0000000000000000 <testovf>:
   0:   31 c0                   xor    %eax,%eax
   2:   c3                      retq

   
   
   Disassembly of section .text: // with -O2 -fsanitize=undefined

0000000000000000 <testovf>:
   0:   55                      push   %rbp 
   1:   53                      push   %rbx
   2:   48 ba ff ff ff ff ff    movabs $0x7fffffffffffffff,%rdx // rdx = 0x7fffffffffffffff
   9:   ff ff 7f
   c:   48 83 ec 08             sub    $0x8,%rsp // rsp = rsp - 0x8
  10:   48 8b 1d 00 00 00 00    mov    0x0(%rip),%rbx        # 17 <testovf+0x17> // rbx = M[0x17]
  17:   48 89 dd                mov    %rbx,%rbp // rbp = M[0x17]
  1a:   48 01 d5                add    %rdx,%rbp // rbp = M[0x17] + 0x7fffffffffffffff
  1d:   70 0d                   jo     2c <testovf+0x2c> // Jump to 2c if the add above caused overflow
  1f:   48 39 eb                cmp    %rbp,%rbx // rbx - rbp 
  22:   0f 9f c0                setg   %al // if rbx - rbp > ---> rbx > rbp, then setg flag
  25:   48 83 c4 08             add    $0x8,%rsp // rsp += 0x8
  29:   5b                      pop    %rbx 
  2a:   5d                      pop    %rbp
  2b:   c3                      retq
  2c:   48 89 de                mov    %rbx,%rsi // rsi = M[0x17]
  2f:   bf 00 00 00 00          mov    $0x0,%edi // edi = 0x0
  34:   e8 00 00 00 00          callq  39 <testovf+0x39> // call 39
  39:   eb e4                   jmp    1f <testovf+0x1f> // direct jmp back to 1f
  
  
  Disassembly of section .text: // with -O2 -fwrapv. 

0000000000000000 <testovf>:
   0:   48 8b 15 00 00 00 00    mov    0x0(%rip),%rdx        # 7 <testovf+0x7> // rdx = M[0x7]
   7:   48 b8 ff ff ff ff ff    movabs $0x7fffffffffffffff,%rax // rax = 0x7fffffffffffffff
   e:   ff ff 7f
  11:   48 01 d0                add    %rdx,%rax // rax = 0x7fffffffffffffff + M[0x7]
  14:   48 39 c2                cmp    %rax,%rdx // rdx - rax 
  17:   0f 9f c0                setg   %al // if rdx > rax, set al t
  1a:   c3                      retq
  
Compare the resulting assembly-language files, and describe and justify the differences that you see. 
Put your description into a plain ASCII text file testovf.txt:

The three different assembly-language files are compiled with -O2, -O2 -fsanitize=undefined, and -O2 -fwrapv respectively. In terms of amount of assembly line code, -O2 has the least, then -O2 -fwrapv, and lastly -O2 -fsanitize=undefined. For -O2, the optimization literally just uses the xor assembly to mirror the contents of the function. That is, if eax disagrees then it will return true, else it shouldn't. But in this case, it will always return 0 and disregards any comparison because big + c < big is always false in a logical note. For -O2 -fsanitize=undefined, this compilation is geared and enabled to detect undefined behavior at runtime and give a diagnostic message. More specifically, after pushing rbx and rbp onto the stack frame, it moves the 64 bit immediate 0x7fffffffffffffff into rdx. Then the stack is grown by subtracting 0x8 and the addition is ultimately performed. If the addition operation caused an overflow, the machine code would jump to a new block of code in which rsi is given rbx's M[0x17], and edi is given the immediate 0 before directly jumping back to the instruction following the first overflow check. This is similar to -ftrapv but instead of traps being set for signed overflows, alerts are given. "The code may never call the testovf fxn."Lastly for -O2 -fwrapv, this instructs the compiler let signed arithmetic overflow wrap around using 2's complements representation. Rdx is given the value inside memory of the 0x7 instruction. Then the immediate LONG_MAX is loaded into rax where the addition occurs after. Then the comparison is made and set if rdx is greater than rax as we have seen. For context, rdx holds big and rax holds LONGMAX in the beginning. 

================================================================================================================

trace.tr.txt

0x00000000005438c0 <Ftimes+0>:data.c:2767                 mov  %rsi,%rdx                   rdx = 0x7fffffffd9a0
0x00000000005438c3 <Ftimes+3>:data.c:2768                 mov    %rdi,%rsi                 rsi = 0x3
0x00000000005438c6 <Ftimes+6>:data.c:2768                 mov    $0x2,%edi                 edi = 0x2
0x00000000005438cb <Ftimes+11>:data.c:2768                jmpq   0x543500 <arith_driver>   rip = 0x543500
0x0000000000543500 <arith_driver+0>:data.c:2577           push   %r15   M8[0x7fffffffd990] = 0xbab772 rsp = 0x7fffffffd990
0x0000000000543502 <arith_driver+2>:data.c:2577           push   %r14   M8[0x7fffffffd988] = 0x7fffffffd9a0  rsp = 0x7fffffffd988
0x0000000000543504 <arith_driver+4>:data.c:2577           push   %r13   M8[0x7fffffffd980] = 0x180 rsp = 0x7fffffffd980
0x0000000000543506 <arith_driver+6>:data.c:2577           push   %r12   M8[0x7fffffffd978] = 0xafa950  rsp = 0x7fffffffd978
0x0000000000543508 <arith_driver+8>:data.c:2577           push   %rbp   M8[0x7fffffffd970] = 0x7fffffffda70 rsp = 0x7fffffffd970
0x0000000000543509 <arith_driver+9>:data.c:2577           push   %rbx   M8[0x7fffffffd968] = 0x7fffffffd9b8 rsp = 0x7fffffffd968
0x000000000054350a <arith_driver+10>:data.c:2577          mov    $0x1,%ebp ebp = 0x1
0x000000000054350f <arith_driver+15>:data.c:2577          sub    $0x18,%rsp rsp = 0x7fffffffd950
0x0000000000543513 <arith_driver+19>:data.c:2584          cmp    $0x2,%edi
0x0000000000543516 <arith_driver+22>:data.c:2584          je     0x543525 <arith_driver+37> rip = 0x543525
0x0000000000543525 <arith_driver+37>:data.c:2602          test   %rsi,%rsi
0x0000000000543528 <arith_driver+40>:data.c:2602          jle    0x5436ab <arith_driver+427> rip = 0x54352e
0x000000000054352e <arith_driver+46>:data.c:2602          mov    %rdx,%r15 r15 = 0x7fffffffd9a0
0x0000000000543531 <arith_driver+49>:data.c:2602          mov    %rsi,%r13 r13 = 0x3
0x0000000000543534 <arith_driver+52>:data.c:2602          mov    %edi,%r14d r14d = 0x2
0x0000000000543537 <arith_driver+55>:data.c:2602          mov    %rbp,%r11 r11 = 0x1
0x000000000054353a <arith_driver+58>:data.c:2602          xor    %ecx,%ecx rcx = 0
0x000000000054353c <arith_driver+60>:data.c:2602          xor    %ebx,%ebx ebx = 0
0x000000000054353e <arith_driver+62>:data.c:2602          xor    %r12d,%r12d r12dd = 0x0
0x0000000000543541 <arith_driver+65>:data.c:2611          mov    (%r15,%rbx,8),%rdi rdi = 0x6d54
0x0000000000543545 <arith_driver+69>:lisp.h:703           mov    %edi,%eax eax = 0x6d54
0x0000000000543547 <arith_driver+71>:lisp.h:703           mov    %edi,%esi esi = 0x6d54
0x0000000000543549 <arith_driver+73>:lisp.h:703           and    $0x7,%eax eax = 0x4
0x000000000054354c <arith_driver+76>:lisp.h:2384          cmp    $0x3,%eax eax = 0x4
0x000000000054354f <arith_driver+79>:lisp.h:2384          je     0x5435cf <arith_driver+207> rip = 0x543551
0x0000000000543551 <arith_driver+81>:lisp.h:2384          nopl   0x0(%rax)
0x0000000000543558 <arith_driver+88>:data.c:2612          test   $0x3,%dil
0x000000000054355c <arith_driver+92>:data.c:2612          mov    0x634b35(%rip),%rdx # 0xb78098 rdx = 0xbb8902
0x0000000000543563 <arith_driver+99>:data.c:2612          je     0x54356e <arith_driver+110> rip = 0x54356e
0x000000000054356e <arith_driver+110>:data.c:2614         cmp    $0x7,%eax eax = 0x4
0x0000000000543571 <arith_driver+113>:data.c:2614         je     0x54379c <arith_driver+668> rip = 0x543577
0x0000000000543577 <arith_driver+119>:data.c:2617         mov    %rdi,(%r15,%rbx,8) M8[0x7fffffffd9a0] = 0x6d54
0x000000000054357b <arith_driver+123>:lisp.h:701          sar    $0x2,%rdi rdi = 0x1b55
0x000000000054357f <arith_driver+127>:data.c:2619         cmp    $0x8,%r14d  r14d = 0x2
0x0000000000543583 <arith_driver+131>:data.c:2619         ja     0x5435a8 <arith_driver+168> rip = 0x543585
0x0000000000543585 <arith_driver+133>:data.c:2619         mov    %r14d,%eax eax = 0x2
0x0000000000543588 <arith_driver+136>:data.c:2619         jmpq   *0x5ec2a0(,%rax,8) rip = 0x543600
0x0000000000543600 <arith_driver+256>:data.c:2638         test   %rdi,%rdi rdi = 0x1b55
0x0000000000543603 <arith_driver+259>:data.c:2638         js     0x5437d8 <arith_driver+728> rip = 0x543609
0x0000000000543609 <arith_driver+265>:data.c:2638         je     0x5437c8 <arith_driver+712> rip = 0x54360f 
0x000000000054360f <arith_driver+271>:data.c:2638         test   %rbp,%rbp  rbp = 1
0x0000000000543612 <arith_driver+274>:data.c:2638         js     0x543838 <arith_driver+824> rip = 0x543618
0x0000000000543618 <arith_driver+280>:data.c:2638         movabs $0x7fffffffffffffff,%rax rax = 0x7fffffffffffffff
0x0000000000543622 <arith_driver+290>:data.c:2638         cqto   rdx = 0
0x0000000000543624 <arith_driver+292>:data.c:2638         idiv   %rdi rdx = 0x8a4 rax = 0x4aee2e9caa7ef
0x0000000000543627 <arith_driver+295>:data.c:2638         cmp    %rbp,%rax 
0x000000000054362a <arith_driver+298>:data.c:2638         setl   %al rax = 0x4aee2e9caa700
0x000000000054362d <arith_driver+301>:data.c:2638         test   %al,%al
0x000000000054362f <arith_driver+303>:data.c:2638         je     0x5437c8 <arith_driver+712> rip = 0x5437c8
0x00000000005437c8 <arith_driver+712>:data.c:2645         imul   %rdi,%rbp rbp = 0x1b55
0x00000000005437cc <arith_driver+716>:data.c:2645         jmpq   0x5435a8 <arith_driver+168> rip = 0x5435a8
0x00000000005435a8 <arith_driver+168>:data.c:2602         add    $0x1,%rbx rbx = 0x1
0x00000000005435ac <arith_driver+172>:data.c:2602         cmp    %rbx,%r13
0x00000000005435af <arith_driver+175>:data.c:2602         je     0x5436ab <arith_driver+427> rip = 0x5435b5
0x00000000005435b5 <arith_driver+181>:data.c:2611         mov    (%r15,%rbx,8),%rdi rdi = 0xffff60000a000004
0x00000000005435b9 <arith_driver+185>:data.c:2611         test   %cl,%cl cl = 0x0
0x00000000005435bb <arith_driver+187>:data.c:2611         cmove  %rbp,%r11 r11 = 0x1b55
0x00000000005435bf <arith_driver+191>:data.c:2611         cmove  %rbx,%r12 r12 = 0x1
0x00000000005435c3 <arith_driver+195>:lisp.h:703          mov    %edi,%eax eax = 0xa000004
0x00000000005435c5 <arith_driver+197>:lisp.h:703          mov    %edi,%esi esi = 0xa000004
0x00000000005435c7 <arith_driver+199>:lisp.h:703          and    $0x7,%eax eax = 0x4
0x00000000005435ca <arith_driver+202>:lisp.h:2384         cmp    $0x3,%eax
0x00000000005435cd <arith_driver+205>:lisp.h:2384         jne    0x543558 <arith_driver+88> rip = 0x543558
0x0000000000543558 <arith_driver+88>:data.c:2612          test   $0x3,%dil
0x000000000054355c <arith_driver+92>:data.c:2612          mov    0x634b35(%rip),%rdx        # 0xb78098 rdx = 0xbb8902
0x0000000000543563 <arith_driver+99>:data.c:2612          je     0x54356e <arith_driver+110> rip = 0x54356e
0x000000000054356e <arith_driver+110>:data.c:2614         cmp    $0x7,%eax
0x0000000000543571 <arith_driver+113>:data.c:2614         je     0x54379c <arith_driver+668> rip = 0x543577
0x0000000000543577 <arith_driver+119>:data.c:2617         mov    %rdi,(%r15,%rbx,8) M8[0x7fffffffd990+0x8] = 0xffff60000a000004
0x000000000054357b <arith_driver+123>:lisp.h:701          sar    $0x2,%rdi rdi = 0xffffd80002800001
0x000000000054357f <arith_driver+127>:data.c:2619         cmp    $0x8,%r14d
0x0000000000543583 <arith_driver+131>:data.c:2619         ja     0x5435a8 <arith_driver+168> rip = 0x543585
0x0000000000543585 <arith_driver+133>:data.c:2619         mov    %r14d,%eax eax = 0x2
0x0000000000543588 <arith_driver+136>:data.c:2619         jmpq   *0x5ec2a0(,%rax,8) rip = 0x543600
0x0000000000543600 <arith_driver+256>:data.c:2638         test   %rdi,%rdi
0x0000000000543603 <arith_driver+259>:data.c:2638         js     0x5437d8 <arith_driver+728> rip = 0x5437d8
0x00000000005437d8 <arith_driver+728>:data.c:2638         test   %rbp,%rbp
0x00000000005437db <arith_driver+731>:data.c:2638         js     0x543852 <arith_driver+850> rip = 0x5437dd
0x00000000005437dd <arith_driver+733>:data.c:2638         cmp    $0xffffffffffffffff,%rdi
0x00000000005437e1 <arith_driver+737>:data.c:2638         je     0x5437c8 <arith_driver+712> rip = 0x5437e3
0x00000000005437e3 <arith_driver+739>:data.c:2638         movabs $0x8000000000000000,%rax rax = 0x8000000000000000
0x00000000005437ed <arith_driver+749>:data.c:2638         cqto  rdx = 0xffffffffffffffff
0x00000000005437ef <arith_driver+751>:data.c:2638         idiv   %rdi rax = 0x33333
0x00000000005437f2 <arith_driver+754>:data.c:2638         cmp    %rbp,%rax
0x00000000005437f5 <arith_driver+757>:data.c:2638         setl   %al  rax = 0x33300
0x00000000005437f8 <arith_driver+760>:data.c:2638         jmpq   0x54362d <arith_driver+301> rip = 0x54362d
0x000000000054362d <arith_driver+301>:data.c:2638         test   %al,%al
0x000000000054362f <arith_driver+303>:data.c:2638         je     0x5437c8 <arith_driver+712> rip = 0x5437c8
0x00000000005437c8 <arith_driver+712>:data.c:2645         imul   %rdi,%rbp rbp = 0xfbbab84454801b55
0x00000000005437cc <arith_driver+716>:data.c:2645         jmpq   0x5435a8 <arith_driver+168> rip = 0x5435a8
0x00000000005435a8 <arith_driver+168>:data.c:2602         add    $0x1,%rbx rbx = 0x2
0x00000000005435ac <arith_driver+172>:data.:2602          cmp    %rbx,%r13
0x00000000005435af <arith_driver+175>:data.c:2602         je     0x5436ab <arith_driver+427> rip = 0x5435b5
0x00000000005435b5 <arith_driver+181>:data.c:2611         mov    (%r15,%rbx,8),%rdi rdi = 0x2cc
0x00000000005435b9 <arith_driver+185>:data.c:2611         test   %cl,%cl
0x00000000005435bb <arith_driver+187>:data.c:2611         cmove  %rbp,%r11 r11 = 0xfbbab84454801b55
0x00000000005435bf <arith_driver+191>:data.c:2611         cmove  %rbx,%r12 r12 = 0x2
0x00000000005435c3 <arith_driver+195>:lisp.h:703          mov    %edi,%eax eax = 0x2cc
0x00000000005435c5 <arith_driver+197>:lisp.h:703          mov    %edi,%esi esi = 0x2cc
0x00000000005435c7 <arith_driver+199>:lisp.h:703          and    $0x7,%eax eax = 0x4
0x00000000005435ca <arith_driver+202>:lisp.h:2384         cmp    $0x3,%eax
0x00000000005435cd <arith_driver+205>:lisp.h:2384         jne    0x543558 <arith_driver+88> rip = 0x543558
0x0000000000543558 <arith_driver+88>:data.c:2612          test   $0x3,%dil
0x000000000054355c <arith_driver+92>:data.c:2612          mov    0x634b35(%rip),%rdx        # 0xb78098 rdx = 0xbb8902
0x0000000000543563 <arith_driver+99>:data.c:2612          je     0x54356e <arith_driver+110> rip = 0x54356e
0x000000000054356e <arith_driver+110>:data.c:2614         cmp    $0x7,%eax
0x0000000000543571 <arith_driver+113>:data.c:2614         je     0x54379c <arith_driver+668> rip = 0x543577
0x0000000000543577 <arith_driver+119>:data.c:2617         mov    %rdi,(%r15,%rbx,8) M8[0x7fffffffd990 + 0x2] = 0x2cc
0x000000000054357b <arith_driver+123>:lisp.h:701          sar    $0x2,%rdi rdi = 0xb3
0x000000000054357f <arith_driver+127>:data.c:2619         cmp    $0x8,%r14d
0x0000000000543583 <arith_driver+131>:data.c:2619         ja     0x5435a8 <arith_driver+168> rip = 0x543585
0x0000000000543585 <arith_driver+133>:data.c:2619         mov    %r14d,%eax eax = 0x2
0x0000000000543588 <arith_driver+136>:data.c:2619         jmpq   *0x5ec2a0(,%rax,8) rip = 0x543600
0x0000000000543600 <arith_driver+256>:data.c:2638         test   %rdi,%rdi
0x0000000000543603 <arith_driver+259>:data.c:2638         js     0x5437d8 <arith_driver+728> rip = 0x543609
0x0000000000543609 <arith_driver+265>:data.c:2638         je     0x5437c8 <arith_driver+712> rip = 0x54360f
0x000000000054360f <arith_driver+271>:data.c:2638         test   %rbp,%rbp
0x0000000000543612 <arith_driver+274>:data.c:2638         js     0x543838 <arith_driver+824> rip = 0x543838
0x0000000000543838 <arith_driver+824>:data.c:2638         movabs $0x8000000000000000,%rax rax = 0x8000000000000000
0x0000000000543842 <arith_driver+834>:data.c:2638         cqto    rdx = 0xffffffffffffffff
0x0000000000543844 <arith_driver+836>:data.c:2638         idiv   %rdi rax = 0xff48f044a5e641ca
0x0000000000543847 <arith_driver+839>:data.c:2638         cmp    %rbp,%rax
0x000000000054384a <arith_driver+842>:data.c:2638         setg   %al      rax = 0xff48f044a5e64101
0x000000000054384d <arith_driver+845>:data.c:2638         jmpq   0x54362d <arith_driver+301> rip = 0x54362d
0x000000000054362d <arith_driver+301>:data.c:2638         test   %al,%al
0x000000000054362f <arith_driver+303>:data.c:2638         je     0x5437c8 <arith_driver+712> rip = 0x5437c8
0x00000000005437c8 <arith_driver+712>:data.c:2645         imul   %rdi,%rbp rbp = 0x1b55
0x00000000005437cc <arith_driver+716>:data.c:2645         jmpq   0x5435a8 <arith_driver+168> rip = 0x5435a8
0x00000000005435a8 <arith_driver+168>:data.c:2602         add    $0x1,%rbx = 0x1
0x00000000005435ac <arith_driver+172>:data.c:2602         cmp    %rbx,%r13
0x00000000005435af <arith_driver+175>:data.c:2602         je     0x5436ab <arith_driver+427> rip = 0x5436ab
0x00000000005436ab <arith_driver+427>:data.c:2679         add    $0x18,%rsp rsp = 0x7fffffffd958
0x00000000005436af <arith_driver+431>:lisp.h:700          lea    0x0(,%rbp,4),%rax rax = 0xe3b5f1c564c71bc
0x00000000005436b7 <arith_driver+439>:data.c:2679         pop    %rbx rbx = 0x7fffffffd9a8
0x00000000005436b8 <arith_driver+440>:data.c:2679         pop    %rbp rbp = 0x7fffffffda60
0x00000000005436b9 <arith_driver+441>:data.c:2679         pop    %r12 r12 = 0xafa950
0x00000000005436bb <arith_driver+443>:data.c:2679         pop    %r13 r13 = 0x180
0x00000000005436bd <arith_driver+445>:data.c:2679         pop    %r14 r14 = 0x7fffffffd990
0x00000000005436bf <arith_driver+447>:data.c:2679         pop    %r15 r15 = 0xbab772
0x00000000005436c1 <arith_driver+449>:data.c:2679         retq    rip = 0x556de1 rsp = 0x7fffffffd990
